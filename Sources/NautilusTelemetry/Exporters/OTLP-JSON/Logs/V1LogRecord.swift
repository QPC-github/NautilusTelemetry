//
// V1LogRecord.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech
//

import Foundation

extension OTLP {
	struct V1LogRecord: Codable, Equatable {
		/** time_unix_nano is the time when the event occurred. Value is UNIX Epoch time in nanoseconds since 00:00:00 UTC on 1 January 1970. Value of 0 indicates unknown or missing timestamp. */
		internal let timeUnixNano: String?
		internal let severityNumber: V1SeverityNumber?
		/** The severity text (also known as log level). The original string representation as it is known at the source. [Optional]. */
		internal let severityText: String?
		/** Short event identifier that does not contain varying parts. Name describes what happened (e.g. \"ProcessStarted\"). Recommended to be no longer than 50 characters. Not guaranteed to be unique in any way. [Optional]. */
		internal let name: String?
		internal let body: V1AnyValue?
		/** Additional attributes that describe the specific event occurrence. [Optional]. */
		internal let attributes: [V1KeyValue]?
		internal let droppedAttributesCount: Int64?
		/** Flags, a bit field. 8 least significant bits are the trace flags as defined in W3C Trace Context specification. 24 most significant bits are reserved and must be set to 0. Readers must not assume that 24 most significant bits will be zero and must correctly mask the bits when reading 8-bit trace flag (use flags & TRACE_FLAGS_MASK). [Optional]. */
		internal let flags: Int64?
		/** A unique identifier for a trace. All logs from the same trace share the same `trace_id`. The ID is a 16-byte array. An ID with all zeroes is considered invalid. Can be set for logs that are part of request processing and have an assigned trace id. [Optional]. */
		internal let traceId: Data?
		/** A unique identifier for a span within a trace, assigned when the span is created. The ID is an 8-byte array. An ID with all zeroes is considered invalid. Can be set for logs that are part of a particular processing span. If span_id is present trace_id SHOULD be also present. [Optional]. */
		internal let spanId: Data?

		internal init(timeUnixNano: String?, severityNumber: V1SeverityNumber?, severityText: String?, name: String?, body: V1AnyValue?, attributes: [V1KeyValue]?, droppedAttributesCount: Int64?, flags: Int64?, traceId: Data?, spanId: Data?) {
			self.timeUnixNano = timeUnixNano
			self.severityNumber = severityNumber
			self.severityText = severityText
			self.name = name
			self.body = body
			self.attributes = attributes
			self.droppedAttributesCount = droppedAttributesCount
			self.flags = flags
			self.traceId = traceId
			self.spanId = spanId
		}

		internal enum CodingKeys: String, CodingKey, CaseIterable {
			case timeUnixNano = "time_unix_nano"
			case severityNumber = "severity_number"
			case severityText = "severity_text"
			case name
			case body
			case attributes
			case droppedAttributesCount = "dropped_attributes_count"
			case flags
			case traceId = "trace_id"
			case spanId = "span_id"
		}
	}
}
