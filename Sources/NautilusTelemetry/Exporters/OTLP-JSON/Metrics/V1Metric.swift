//
// V1Metric.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech
//

import Foundation

extension OTLP {
	
	// Defines a Metric which has one or more timeseries.  The following is a
	// brief summary of the Metric data model.  For more details, see:
	//
	//   https://github.com/open-telemetry/opentelemetry-specification/blob/main/specification/metrics/datamodel.md
	//
	//
	// The data model and relation between entities is shown in the
	// diagram below. Here, "DataPoint" is the term used to refer to any
	// one of the specific data point value types, and "points" is the term used
	// to refer to any one of the lists of points contained in the Metric.
	//
	// - Metric is composed of a metadata and data.
	// - Metadata part contains a name, description, unit.
	// - Data is one of the possible types (Sum, Gauge, Histogram, Summary).
	// - DataPoint contains timestamps, attributes, and one of the possible value type
	//   fields.
	//
	//     Metric
	//  +------------+
	//  |name        |
	//  |description |
	//  |unit        |     +------------------------------------+
	//  |data        |---> |Gauge, Sum, Histogram, Summary, ... |
	//  +------------+     +------------------------------------+
	//
	//    Data [One of Gauge, Sum, Histogram, Summary, ...]
	//  +-----------+
	//  |...        |  // Metadata about the Data.
	//  |points     |--+
	//  +-----------+  |
	//                 |      +---------------------------+
	//                 |      |DataPoint 1                |
	//                 v      |+------+------+   +------+ |
	//              +-----+   ||label |label |...|label | |
	//              |  1  |-->||value1|value2|...|valueN| |
	//              +-----+   |+------+------+   +------+ |
	//              |  .  |   |+-----+                    |
	//              |  .  |   ||value|                    |
	//              |  .  |   |+-----+                    |
	//              |  .  |   +---------------------------+
	//              |  .  |                   .
	//              |  .  |                   .
	//              |  .  |                   .
	//              |  .  |   +---------------------------+
	//              |  .  |   |DataPoint M                |
	//              +-----+   |+------+------+   +------+ |
	//              |  M  |-->||label |label |...|label | |
	//              +-----+   ||value1|value2|...|valueN| |
	//                        |+------+------+   +------+ |
	//                        |+-----+                    |
	//                        ||value|                    |
	//                        |+-----+                    |
	//                        +---------------------------+
	//
	// Each distinct type of DataPoint represents the output of a specific
	// aggregation function, the result of applying the DataPoint's
	// associated function of to one or more measurements.
	//
	// All DataPoint types have three common fields:
	// - Attributes includes key-value pairs associated with the data point
	// - TimeUnixNano is required, set to the end time of the aggregation
	// - StartTimeUnixNano is optional, but strongly encouraged for DataPoints
	//   having an AggregationTemporality field, as discussed below.
	//
	// Both TimeUnixNano and StartTimeUnixNano values are expressed as
	// UNIX Epoch time in nanoseconds since 00:00:00 UTC on 1 January 1970.
	//
	// # TimeUnixNano
	//
	// This field is required, having consistent interpretation across
	// DataPoint types.  TimeUnixNano is the moment corresponding to when
	// the data point's aggregate value was captured.
	//
	// Data points with the 0 value for TimeUnixNano SHOULD be rejected
	// by consumers.
	//
	// # StartTimeUnixNano
	//
	// StartTimeUnixNano in general allows detecting when a sequence of
	// observations is unbroken.  This field indicates to consumers the
	// start time for points with cumulative and delta
	// AggregationTemporality, and it should be included whenever possible
	// to support correct rate calculation.  Although it may be omitted
	// when the start time is truly unknown, setting StartTimeUnixNano is
	// strongly encouraged.
	struct V1Metric: Codable, Equatable {
		/** name of the metric, including its DNS name prefix. It must be unique. */
		internal let name: String?
		/** description of the metric, which can be used in documentation. */
		internal let description: String?
		/** unit in which the metric value is reported. Follows the format described by http://unitsofmeasure.org/ucum.html. */
		internal let unit: String?
		internal let gauge: V1Gauge?
		internal let sum: V1Sum?
		internal let histogram: V1Histogram?
		internal let exponentialHistogram: V1ExponentialHistogram?
		internal let summary: V1Summary?

		internal init(name: String?, description: String?, unit: String?, gauge: V1Gauge? = nil, sum: V1Sum? = nil, histogram: V1Histogram? = nil, exponentialHistogram: V1ExponentialHistogram? = nil, summary: V1Summary? = nil) {
			self.name = name
			self.description = description
			self.unit = unit
			self.gauge = gauge
			self.sum = sum
			self.histogram = histogram
			self.exponentialHistogram = exponentialHistogram
			self.summary = summary
		}

		internal enum CodingKeys: String, CodingKey, CaseIterable {
			case name
			case description
			case unit
			case gauge
			case sum
			case histogram
			case exponentialHistogram = "exponential_histogram"
			case summary
		}
	}
}
